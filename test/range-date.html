<!doctype html>
<html>
<head>
	<title>cosmoz-omnitable range tests for date, datetime, time</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

	<script src="../../webcomponentsjs/webcomponents-lite.js"></script>
	<script src="../../web-component-tester/browser.js"></script>
	<script src="../../test-fixture/test-fixture-mocha.js"></script>

	<link rel="import" href="../../test-fixture/test-fixture.html">
	<link rel="import" href="../../iron-test-helpers/iron-test-helpers.html">

	<link rel="import" href="../cosmoz-omnitable.html">
	<link rel="import" href="../cosmoz-omnitable-columns.html">
	<link rel="import" href="../demo/table-demo-behavior.html">
</head>
<body>
	<test-fixture id="range">
		<template>
			<cosmoz-omnitable id="omnitable" class="flex">
				<cosmoz-omnitable-column-number title="Age" name="age" value-path="age">
				</cosmoz-omnitable-column-number>
				<cosmoz-omnitable-column-amount title="Amount" name="amount" value-path="amount">
				</cosmoz-omnitable-column-amount>
				<cosmoz-omnitable-column-date title="Date" name="date" value-path="date" locale="en-US" editable>
				</cosmoz-omnitable-column-date>
				<cosmoz-omnitable-column-datetime title="Datetime" name="datetime" value-path="date" editable>
				</cosmoz-omnitable-column-datetime>
				<cosmoz-omnitable-column-time title="Time" name="time" value-path="time" editable>
				</cosmoz-omnitable-column-time>
			</cosmoz-omnitable>
		</template>
	</test-fixture>

	<script>
	/*global sinon chai flush */
	(function () {
		'use strict';
		const data = [
			{ age: 17,
				amount: { amount: '12.4', currency: 'USD' },
				date: '2023-03-21Z',
				time: ''
			},
			{ amount: { amount: 2 },
				date: new Date('2015-03-18Z')
			},
			{ age: -11,
				amount: { amount: 678, currency: 'AUD' },
				date: new Date(86400000), // Fri Jan 02 1970
				time: 86400000
			},
			{ age: 9,
				amount: { amount: -8, currency: 'EUR' },
				date: new Date(99, 5, 24, 11, 33, 30, 0), // Thu Jun 24 1999 11:33:30 GMT+0300 (EEST)
				time: '86400000'
			},
			{
				age: 5,
				amount: { amount: '3450', currency: 'DKK' },
				date: new Date('2016-08-27'),
				time: '2016-08-27T14:34:56Z'
			}
		];

		sinon.assert.expose(chai.assert, { prefix: '' });

		suite('date', function () {
			let omnitable,
				column;

			setup(function (done) {
				omnitable = fixture('range');
				omnitable.data = data;
				Polymer.Base.async(function () {
					column = omnitable.columns[2];
					done();
				}, 90);
			});

			test('instantiates a cosmoz-omnitable-column-date', function (done) {
				assert.equal(column.is, 'cosmoz-omnitable-column-date');
				done();
			});

			test('toDate converts an value to valid date', function (done) {
				assert.equal(column.toDate(data[0].date).getTime(), new Date('2023-03-21Z').getTime());
				assert.equal(column.toDate(data[1].date).getTime(), new Date('2015-03-18Z').getTime());
				assert.equal(column.toDate(data[2].date).getTime(), new Date(Date.UTC(1970, 0, 2)).getTime());
				done();
			});

			test('toDate limits parameters', function (done) {
				assert.equal(column.toDate(data[0].date, '2023-03-21T00:00:00Z', Math.min), (new Date('2023-03-21T00:00:00Z')).getTime()); // min
				assert.equal(column.toDate(data[1].date, '2053-04-21T00:00:00Z', Math.min), (new Date('2015-03-18T00:00:00Z')).getTime()); // min
				assert.equal(column.toDate(data[0].date, (new Date('2023-04-21T00:00:00Z')).getTime(), Math.max), (new Date('2023-04-21T00:00:00Z')).getTime()); //max
				assert.equal(column.toDate(data[1].date, '2017-03-18T00:00:00Z').getTime(), (new Date('2015-03-18T00:00:00Z')).getTime()); // missing limitFunc returns date
				done();
			});

			test('date returns comparable values', function (done) {
				assert.typeOf(column.getComparableValue(data[0].date), 'number');
				assert.typeOf(column.getComparableValue(data[1].date), 'number');
				assert.typeOf(column.getComparableValue(data[2].date), 'number');
				done();
			});

			test('getString returns formated date', function (done) {
				assert.equal(column.getString(), '');
				assert.isString(column.getString(data[0], 'date'));
				assert.equal(column.getString(data[1]), '3/18/2015');
				assert.equal(column.getString(data[3], 'date'), '6/24/1999');
				assert.equal(column.getString(data[4]), '8/27/2016');
				done();
			});

			test('_toLocalISOString returns formated date', function (done) {
				assert.equal(column._toLocalISOString(data[4].date), '2016-08-27T03:00:00.000');
				done();
			});

			test('changing filter updates _filterInput', function (done) {
				assert.isNull(column.filter.min);
				assert.isNull(column.filter.max);

				column.filter = {
					min: new Date('2015-03-18'),
					max: new Date('2023-03-21')
				};

				assert.equal(column._filterInput.min, '2015-03-18', 'Expect _filterInput.min to be local ISO String');
				assert.equal(column._filterInput.max, '2023-03-21', 'Expect _filterInput.max to be local ISO String');

				assert.equal(new Date(column._filterInput.min).getTime(), column.filter.min.getTime(), 'Expect min input and filter to be equal as dates');
				assert.equal(new Date(column._filterInput.max).getTime(), column.filter.max.getTime(), 'Expect max input and filter to be equal as dates');

				done();
			});

			test('changing _filterInput updates filter', function (done) {
				assert.isNull(column._filterInput.min);
				assert.isNull(column._filterInput.max);
				column._filterInput = {
					min: '2015-03-18',
					max: '2023-03-21'
				};
				Polymer.Base.async(function () {
					assert.equal(column.filter.min.getTime(), new Date('2015-03-18T00:00:00Z').getTime());
					assert.equal(column.filter.max.getTime(), new Date('2023-03-21T00:00:00Z').getTime());
					done();
				}, 650);
			});

			test('changing only _filterInput min updates filter min', function (done) {
				column._filterInput.min = '2015-08-27';
				Polymer.Base.async(function () {
					assert.equal(column.filter.min.getTime(), new Date('2015-08-27T00:00:00Z').getTime());
					done();
				}, 650);
			});
		});

		suite('datetime', function () {
			let omnitable,
				column;

			setup(function (done) {
				omnitable = fixture('range');
				omnitable.data = data;
				Polymer.Base.async(function () {
					column = omnitable.columns[3];
					done();
				}, 90);
			});

			test('_toInputString converts datetime to local string', function (done) {
				assert.equal(column._toInputString(data[2].date), '1970-01-02T02:00:00');
				done();
			});

			test('_toHashString converts datetime to UTC string replacing : with .', function (done) {
				assert.equal(column._toHashString(data[2].date), '1970-01-02T00.00.00');
				done();
			});

			test('changing filter updates _filterInput', function (done) {
				assert.isNull(column.filter.min);
				assert.isNull(column.filter.max);
				column.filter = {
					min: data[2].date,
					max: data[3].date
				};
				assert.equal(column._filterInput.min, '1970-01-02T02:00:00');
				assert.equal(column._filterInput.max, '1999-06-24T11:33:30');
				done();
			});

			test('changing _filterInput updates filter', function (done) {
				column._filterInput = {
					min: '1970-01-02T02:00:00',
					max: '1999-06-24T11:33:30'
				};
				Polymer.Base.async(function () {
					assert.equal(column.filter.min.getTime(), 86400000);
					assert.equal(column.filter.max.getTime(), data[3].date.getTime());
					done();
				}, 650);
			});

			test('changing only _filterInput min updates filter min', function (done) {
				column._filterInput.min = '2014-06-24T11:33:30';
				Polymer.Base.async(function () {
					assert.equal(column.filter.min.getTime(), new Date('2014-06-24T11:33:30').getTime());
					done();
				}, 650);
			});
		});

		suite('time', function () {
			let omnitable,
				column;

			setup(function (done) {
				omnitable = fixture('range');
				omnitable.data = data;
				Polymer.Base.async(function () {
					column = omnitable.columns[4];
					done();
				}, 90);
			});

			test('instantiates a cosmoz-omnitable-column-time', function (done) {
				assert.equal(column.is, 'cosmoz-omnitable-column-time');
				done();
			});

			test('time toDate converts timestamp to valid date', function (done) {
				assert.equal(column.toDate(data[0].time), null);
				assert.equal(column.toDate(data[1].time), null);
				assert.equal(column.toDate(data[2].time).getTime(), new Date(Date.UTC(1970, 0, 2)).getTime());
				assert.isNull(column.toDate(data[3].time));
				done();
			});

			test('time toDate accepts time as string and converts it to date', function (done) {
				assert.equal(column.toDate(data[4].time).getTime(), new Date(Date.UTC(2016, 7, 27, 14, 34, 56)).getTime());
				done();
			});

			test('time toDate limits parameters', function (done) {
				assert.equal(column.toDate(data[2].time, '2023-04-21T04:00:00Z', Math.min), new Date(Date.UTC(1970, 0, 2)).getTime()); // min
				assert.equal(column.toDate(data[2].time, '2053-04-21T11:23:32Z', Math.max), new Date('2053-04-21T11:23:32Z').getTime()); // max
				assert.equal(column.toDate(data[4].time, (new Date('2023-04-21T04:00:00Z')).getTime(), Math.min), new Date(Date.UTC(2016, 7, 27, 14, 34, 56)).getTime()); //min
				assert.equal(column.toDate(data[4].time, (new Date('2023-04-21T11:23:32Z')).getTime(), Math.max), new Date('2023-04-21T11:23:32Z').getTime()); //max
				assert.equal(column.toDate(data[4].time, '2017-03-18T11:23:32Z').getTime(), new Date(Date.UTC(2016, 7, 27, 14, 34, 56)).getTime()); // missing limitFunc returns date
				done();
			});

			test('time toDate accepts limit as timestamp', function (done) {
				assert.equal(column.toDate(new Date(Date.UTC(2029, 0, 2)), data[2].time, Math.min), data[2].time);
				done();
			});

			test('time getComparableValue returns right value', function (done) {
				assert.equal(column.getComparableValue(data[2], 'time'), 0, 'Expected to parse time from miliseconds timestamp as number');
				assert.equal(column.getComparableValue(data[4], 'time'), 56096000);
				done();
			});

			test('time _toInputString returns local ISO string', function (done) {
				assert.equal(column._toInputString(), null);
				assert.equal(column._toInputString(data[2].time), '02:00:00');
				assert.equal(column._toInputString(data[4].time), '17:34:56');
				done();
			});

			test('time _toHashString converts time to UTC string replacing : with .', function (done) {
				assert.equal(column._toHashString(data[2].time), '00.00.00');
				done();
			});

			test('changing filter updates _filterInput', function (done) {
				assert.isNull(column.filter.min);
				assert.isNull(column.filter.max);
				column.filter = {
					min: data[2].time,
					max: data[4].time
				};
				assert.equal(column._filterInput.min, '02:00:00');
				assert.equal(column._filterInput.max, '17:34:56');
				done();
			});

			test('changing _filterInput updates filter', function (done) {
				assert.isNull(column._filterInput.min);
				assert.isNull(column._filterInput.max);
				column._filterInput = {
					min: '03:10:00',
					max: '14:34:56'
				};
				Polymer.Base.async(function () {
					assert.equal(column.filter.min.getTime(), new Date(Date.UTC(1970, 0, 1, 1, 10)).getTime());
					assert.equal(column.filter.max.getTime(), new Date(Date.UTC(1970, 0, 1, 12, 34, 56)).getTime());
					done();
				}, 650);
			});

			test('changing only _filterInput min updates filter min', function (done) {
				column._filterInput.min = '04:21:10';
				Polymer.Base.async(function () {
					assert.equal(column.filter.min.getTime(), new Date(Date.UTC(1970, 0, 1, 2, 21, 10)).getTime());
					done();
				}, 650);
			});

		});

	}());

	</script>
</body>
</html>
